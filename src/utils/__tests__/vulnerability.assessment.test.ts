/**
 * Vulnerability Assessment Tests
 * Basic security vulnerability checks for Phase 2 implementation
 */

import * as SecureStore from 'expo-secure-store';
import * as Crypto from 'expo-crypto';

// Mock Expo modules
jest.mock('expo-secure-store');
jest.mock('expo-crypto');

const mockSecureStore = SecureStore as jest.Mocked<typeof SecureStore>;
const mockCrypto = Crypto as jest.Mocked<typeof Crypto>;

import { setupPin, verifyPin, changePin } from '../pinAuth';
import { generateSecurePassword } from '../passwordGenerator';

describe('Vulnerability Assessment Tests', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    mockSecureStore.getItemAsync.mockResolvedValue(null);
    mockSecureStore.setItemAsync.mockResolvedValue();
    mockSecureStore.deleteItemAsync.mockResolvedValue();
  });

  describe('PIN Security Vulnerabilities', () => {
    it('should prevent PIN brute force attacks with lockout', async () => {
      // Setup PIN
      mockSecureStore.getItemAsync.mockImplementation((key) => {
        if (key === 'pin_enabled') return Promise.resolve('true');
        if (key === 'user_pin_hash') return Promise.resolve('correct_hash');
        if (key === 'pin_salt') return Promise.resolve('salt');
        if (key === 'pin_attempts') return Promise.resolve('5'); // Max attempts reached
        if (key === 'pin_last_attempt') return Promise.resolve(Date.now().toString());
        return Promise.resolve(null);
      });

      mockCrypto.digestStringAsync.mockResolvedValue('wrong_hash');

      const result = await verifyPin('1234');

      expect(result.isValid).toBe(false);
      expect(result.error).toContain('Too many failed attempts');
    });

    it('should use cryptographically secure hashing for PIN storage', async () => {
      const mockSalt = new Uint8Array(32);
      mockCrypto.getRandomBytesAsync.mockResolvedValue(mockSalt);
      mockCrypto.digestStringAsync.mockResolvedValue('secure_hash_result');

      await setupPin('1234');

      // Verify salt generation
      expect(mockCrypto.getRandomBytesAsync).toHaveBeenCalledWith(32);
      
      // Verify hashing with salt
      expect(mockCrypto.digestStringAsync).toHaveBeenCalledWith(
        Crypto.CryptoDigestAlgorithm.SHA256,
        expect.any(String), // PIN + salt
        expect.objectContaining({
          encoding: Crypto.CryptoEncoding.HEX,
        })
      );

      // Verify secure storage
      expect(mockSecureStore.setItemAsync).toHaveBeenCalledWith(
        'user_pin_hash',
        'secure_hash_result'
      );
    });

    it('should validate PIN format to prevent injection attacks', async () => {
      // Test various malicious inputs
      const maliciousInputs = [
        '', // Empty
        '123', // Too short
        '1234567', // Too long
        'abcd', // Non-numeric
        '12a4', // Mixed
        '1234; DROP TABLE pins;', // SQL injection attempt
        '<script>alert("xss")</script>', // XSS attempt
        '../../../../etc/passwd', // Path traversal
      ];

      for (const input of maliciousInputs) {
        try {
          await setupPin(input);
          fail(`Should have rejected malicious input: ${input}`);
        } catch (error) {
          expect(error).toBeInstanceOf(Error);
          expect((error as Error).message).toContain('PIN must be 4-6 digits');
        }
      }
    });

    it('should prevent timing attacks on PIN verification', async () => {
      // This test ensures verification time is consistent regardless of correctness
      mockSecureStore.getItemAsync.mockImplementation((key) => {
        if (key === 'pin_enabled') return Promise.resolve('true');
        if (key === 'user_pin_hash') return Promise.resolve('correct_hash');
        if (key === 'pin_salt') return Promise.resolve('salt');
        return Promise.resolve(null);
      });

      mockCrypto.digestStringAsync.mockImplementation((input) => {
        // Simulate consistent timing
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(input.includes('1234salt') ? 'correct_hash' : 'wrong_hash');
          }, 10); // Consistent 10ms delay
        });
      });

      const start1 = Date.now();
      await verifyPin('1234'); // Correct PIN
      const time1 = Date.now() - start1;

      const start2 = Date.now();
      await verifyPin('9999'); // Wrong PIN
      const time2 = Date.now() - start2;

      // Time difference should be minimal (within 5ms tolerance)
      expect(Math.abs(time1 - time2)).toBeLessThan(5);
    });
  });

  describe('Password Generation Security', () => {
    it('should use cryptographically secure random number generation', async () => {
      const mockRandomBytes = new Uint8Array([1, 2, 3, 4, 5, 6, 7, 8]);
      mockCrypto.getRandomBytesAsync.mockResolvedValue(mockRandomBytes);

      await generateSecurePassword({
        length: 8,
        includeUppercase: true,
        includeLowercase: true,
        includeNumbers: true,
        includeSymbols: true,
        excludeSimilar: false,
        preventRepeating: false,
      });

      expect(mockCrypto.getRandomBytesAsync).toHaveBeenCalled();
    });

    it('should not leak information through password strength calculation', () => {
      // Test that strength calculation doesn't reveal actual password
      const { calculatePasswordStrength } = require('../strengthCalculator');
      
      const password1 = 'password123';
      const password2 = 'different456';
      
      const strength1 = calculatePasswordStrength(password1);
      const strength2 = calculatePasswordStrength(password2);
      
      // Strengths should be objects without revealing actual passwords
      expect(strength1).not.toHaveProperty('password');
      expect(strength2).not.toHaveProperty('password');
      expect(strength1).toHaveProperty('score');
      expect(strength2).toHaveProperty('score');
    });

    it('should prevent predictable password generation patterns', async () => {
      mockCrypto.getRandomBytesAsync.mockImplementation((length) => {
        // Return different random bytes each time
        return Promise.resolve(new Uint8Array(Array(length).fill(0).map(() => Math.random() * 256)));
      });

      const passwords = [];
      for (let i = 0; i < 10; i++) {
        const result = await generateSecurePassword({
          length: 12,
          includeUppercase: true,
          includeLowercase: true,
          includeNumbers: true,
          includeSymbols: true,
          excludeSimilar: false,
          preventRepeating: false,
        });
        passwords.push(result.password);
      }

      // All passwords should be unique
      const uniquePasswords = new Set(passwords);
      expect(uniquePasswords.size).toBe(passwords.length);
    });
  });

  describe('Memory Security', () => {
    it('should not store sensitive data in component state longer than necessary', () => {
      // This is more of a code review checkpoint
      // In practice, we should verify that:
      // - Passwords are not stored in React state
      // - PIN codes are cleared from memory after use
      // - Authentication tokens are properly cleaned up
      
      // Mock scenario: password should not persist in memory
      const sensitiveData = {
        password: 'secret123',
        pin: '1234',
      };

      // Simulate clearing sensitive data
      sensitiveData.password = '';
      sensitiveData.pin = '';

      expect(sensitiveData.password).toBe('');
      expect(sensitiveData.pin).toBe('');
    });
  });

  describe('Storage Security', () => {
    it('should only use secure storage for sensitive data', async () => {
      // Verify that sensitive operations use SecureStore
      await setupPin('1234');
      
      // Check that sensitive data goes to SecureStore
      expect(mockSecureStore.setItemAsync).toHaveBeenCalledWith(
        'user_pin_hash',
        expect.any(String)
      );
      expect(mockSecureStore.setItemAsync).toHaveBeenCalledWith(
        'pin_salt',
        expect.any(String)
      );
    });

    it('should encrypt all stored sensitive data', async () => {
      // Mock encrypted storage check
      mockSecureStore.getItemAsync.mockResolvedValue('encrypted_data_here');
      
      const storedData = await mockSecureStore.getItemAsync('user_pin_hash');
      
      // In real implementation, this would be encrypted
      expect(storedData).not.toEqual('1234'); // PIN should not be stored in plaintext
      expect(storedData).toBeTruthy(); // But should have some encrypted value
    });
  });

  describe('Authentication Bypass Prevention', () => {
    it('should prevent authentication bypass through settings manipulation', async () => {
      // Try to bypass by disabling security
      mockSecureStore.getItemAsync.mockImplementation((key) => {
        if (key === 'biometric_auth_enabled') return Promise.resolve('false');
        if (key === 'pin_enabled') return Promise.resolve('false');
        return Promise.resolve(null);
      });

      const { isAppLockAvailable } = require('../appLock');
      const isAvailable = await isAppLockAvailable();
      
      // App lock should not be available if no auth methods are configured
      expect(isAvailable).toBe(false);
    });

    it('should validate authentication state consistently', async () => {
      // Mock inconsistent state
      mockSecureStore.getItemAsync.mockImplementation((key) => {
        if (key === 'app_lock_settings') {
          return Promise.resolve(JSON.stringify({ isEnabled: true }));
        }
        if (key === 'user_pin_hash') return Promise.resolve(null); // No PIN
        if (key === 'biometric_auth_enabled') return Promise.resolve('false'); // No biometric
        return Promise.resolve(null);
      });

      const { shouldAppBeLocked } = require('../appLock');
      
      // Should not allow lock without proper auth methods
      const shouldLock = await shouldAppBeLocked();
      expect(shouldLock).toBe(false);
    });
  });

  describe('Error Handling Security', () => {
    it('should not leak sensitive information in error messages', async () => {
      try {
        // Try operation that should fail
        await changePin('wrong_current_pin', '5678');
        fail('Should have thrown an error');
      } catch (error) {
        const errorMessage = (error as Error).message;
        
        // Error should not contain sensitive information
        expect(errorMessage).not.toContain('wrong_current_pin');
        expect(errorMessage).not.toContain('5678');
        expect(errorMessage).not.toContain('hash');
        expect(errorMessage).not.toContain('salt');
        
        // Should be a generic error message
        expect(errorMessage).toContain('incorrect');
      }
    });

    it('should handle secure storage errors gracefully', async () => {
      mockSecureStore.getItemAsync.mockRejectedValue(new Error('Storage error'));
      
      const { isPinConfigured } = require('../pinAuth');
      const result = await isPinConfigured();
      
      // Should default to false on error, not throw
      expect(result).toBe(false);
    });
  });
});